# avi_jsg
 JavaScript Style Guide


## 1.Строки

В строках, объявленных с помощью одинарных и двойных кавычек запрещено использовать переносы

В строках запрещено указывать код спецсимволов в восьмеричной системе счисления

    const foo = "Copyright \251";

    const foo = "Copyright \u00A9";

При создании объектов через литералы свойства должны объявляться в едином стиле: или без кавычек или с ними

В строках используются двойные кавычки. Разрешено использовать строковые шаблоны. Предпочтение отдается строковым шаблонам


## 2.Именование

Все переменные должны быть названы в верблюжьем регистре (camelCase). Исключения составляют константы которые должны именоваться прописными буквами в константном регистре (CONSTANT_CASE) и названия классов, функций-конструкторов и перечислений, которые именуются с заглавной буквы (PascalCase)

Запрещено использовать имена переменных, которые используются во внешних областях видимости

Запрещено называть переменные и свойства [ключевыми словами JS](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Keywords)

Запрещено использовать переменные, не объявленные ранее. При использовании переменной, объявленной в другом модуле в глобальной области видимости нужно обращаться к ней как в свойству объекта `window`

Запрещено напрямую обращаться к значению `undefined`. Для проверки типа рекомендуется использовать `typeof`. Исключение составляет явная передача `undefined` при вызове функции вместо аргумента, чтобы использовать значение параметра по умолчанию



## 3.Предотвращение ошибок

Все точки с запятой должны быть проставлены явно, не стоит рассчитывать на автоматическую расстановку точек с запятой ASI (Automatic Semicolon Insertion)

Не рекомендуется использовать указатель [Unicode BOM](https://en.wikipedia.org/wiki/Byte_order_mark) в коде, потому что код должен быть сохранен не в кодировке UTF-16, а в кодировке UTF-8, в которой нет указателя порядка бит

Обязательно используются блоки кода даже если в выражении содержится одна строчка

В коде нет пустых блоков кода

Код работает в строгом режиме: в начале всех файлов явно прописана директива `"use strict"` или используются модули ECMAScript, которые по умолчанию работают в строгом режиме


## 4.Условные операторы

Запрещена «проверка Йоды» — в условных операторах в блоке условия при сравнении переменной или свойства со значением сначала идет переменная или свойство объекта и только потом значения, а не наоборот.

    if (1 === myValue) { /*...*/ }

    if (myValue === 1) { /*...*/ }

При сравнении двух значений используется оператор строгого сравнения вместо оператора нестрогого сравнения

В условных операторах не используется оператор присвоения

В условиях не используется небезопасное отрицание, например использование `!` в `in` или `instanceof` без скобок

Запрещено сравнение с `NaN`. Для проверки, является ли результат операции числовым, нужно использовать `[Number.isNaN](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN)`

Запрещено использовать `case` без `break` или `return` в блоках `switch`

Не используются вложенные тернарные операторы


## 5.Функции

Если в функции используется ветвление, в котором есть возврат значения, то `return` должен быть добавлен и в остальных ветках.

    const doThings = function() {
      if (cond) {
        return 1;
      } else {
        doSomethingElse();
      }
    };

    const doThings = function() {
      if (cond) {
        return 1;
      } else {
        return doSomethingElse();
      }
    };

Это правило предотвращает создание функций, при использовании которых непонятно, вернут ли они какое-то значение. В первом примере, функция `do` может вернуть значение `1`, а может `undefined`

Единственное исключение — использование `return` без значения для прекращения работы функции:

    const doThings = function() {
      if (cond) {
        doSomething()
        return;
      }

      doSomethingElse();
    };

В `return` не используется оператор присваивания

В стрелочных функциях всегда используются скобки для параметров, даже если параметр один


## 6.Операторы

В конструкторе классов-наследников обязательно вызывается `super()`

В конструкторе нет обращения к `this` до того, как будет вызван `super()`


## 7.Объявление переменных и функций

При объявлении переменных предпочтение отдается ключевым словам `let` и `const`. Переменные объявляются через `var` только при наличии проблем с поддержкой ECMAScript 2015

Запрещено переопределять с помощью ключевого слова ранее созданные переменные

Запрещено использовать множественное объявление через одно ключевое слово. Для каждой переменной используется отдельный `var`, `let` или `const`.

    const a = 1, b = 2;

    const a = 1;
    const b = 2;

### Объявление функций

Запрещено переопределение функций, созданных с помощью функционального объявления (function declaration)

    function myFunc() {};
    myFunc = 2;

Новые функции не создаются с помощью конструктора `Function`

Вместо коллекции `arguments`, используется rest-оператор, если это позволяет версия языка

Для превращения массива с данными в аргументы вместо вызова функции через `apply` используется spread-оператор, если это позволяет версия языка

    Math.max.apply(null, [1, 100, 15, 1000]);

    Math.max(...[1, 100, 15, 1000]);

### Создание значений

Не вызываются служебные конструкторы, создающие объекты из глобальной области видимости `Math()`, `JSON()`, `Reflect()`

При создании непустых массивов запрещено опускать пустые значения (ставить подряд несколько запятых)

При создании непустых объектов и массивов не используются «висячие» запятые

Для создания новых значений не используются конструкторы примитивов `String`, `Number`, `Boolean`

Конструкторы вызываются со скобками, даже если у них нет параметров

Символы (`Symbol`) создаются вызовом функции `Symbol` без ключевого слова `new`



## 8.Хорошие практики

Не используется конструкция `with`

Не используются `alert`

Не используется выполнение кода через `eval`

Не используется неявный `eval` — в функциях, которые поддерживают передачу исполняемого кода как строку, например `setTimeout`

В ссылках используется протокол `javascript:`

Конструкторы не используются без ключевого слова `new`

В функциях не используются обращения к `caller` и `callee`

### Манкипатчинг

Встроенные в язык объекты и прототипы не расширяются в рантайме

Не переопределяются глобальные значения (`undefined`, `null`, `Object`, `window` и прочие)

### Контекст

`bind` не используется вне методов классов

В функциях, которые не являются методами никакого объекта или класса не используется `this`

### Переменные

Переменные, объявленные через `var` не удаляются оператором `delete`


## 9.Приведение типов

Не используется лишнее приведение к Boolean. Например, нет большого смысла переводить в boolean условия в конструкциях `if`, `while`, `for`, в первом операнде тернарного оператора

Оператор `typeof` используется корректно — используются только правильные значения, возвращаемые оператором, не производится сравнения со строковыми литералами, которые содержат некорректные значения `typeof`

В `parseInt` обязательно передается второй параметр — основание системы счисления, даже в случае с десятичной системой счисления

## 10.Константы в условиях

В блоки условия операторов `if`, `while`, `for` и тернарного оператора не передается константное значение, которое подразумевает, что условие выполняется (или не выполняется) всегда

    if (true) {}

    if (a > 1) {}

    const ternaryValue = true ? 'a' : 'b';

    const ternaryValue = isA() ? 'a' : 'b';
